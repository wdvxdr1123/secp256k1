// Copyright 2022 The ecdh Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by addchain. DO NOT EDIT.

package secp256k1

// Invert sets e = 1/x, and returns e.
//
// If x == 0, Invert returns e = 0.
func (e *Element) Invert(x *Element) *Element {
	// Inversion is implemented as exponentiation with exponent p âˆ’ 2.
	// The sequence of 15 multiplications and 255 squarings is derived from the
	// following addition chain generated with github.com/mmcloughlin/addchain v0.4.0.
	//
	//	_10     = 2*1
	//	_100    = 2*_10
	//	_101    = 1 + _100
	//	_111    = _10 + _101
	//	_1110   = 2*_111
	//	_111000 = _1110 << 2
	//	_111111 = _111 + _111000
	//	i13     = _111111 << 4 + _1110
	//	x12     = i13 << 2 + _111
	//	x22     = x12 << 10 + i13 + 1
	//	i29     = 2*x22
	//	i31     = i29 << 2
	//	i54     = i31 << 22 + i31
	//	i122    = (i54 << 20 + i29) << 46 + i54
	//	x223    = i122 << 110 + i122 + _111
	//	i269    = ((x223 << 23 + x22) << 7 + _101) << 3
	//	return    _101 + i269
	//

	var z = new(Element).Set(e)
	var t0 = new(Element)
	var t1 = new(Element)
	var t2 = new(Element)
	var t3 = new(Element)
	var t4 = new(Element)

	t0.Square(x)
	z.Square(t0)
	z.Mul(x, z)
	t1.Mul(t0, z)
	t0.Square(t1)
	t2.Square(t0)
	for s := 1; s < 2; s++ {
		t2.Square(t2)
	}
	t2.Mul(t1, t2)
	for s := 0; s < 4; s++ {
		t2.Square(t2)
	}
	t0.Mul(t0, t2)
	t2.Square(t0)
	for s := 1; s < 2; s++ {
		t2.Square(t2)
	}
	t2.Mul(t1, t2)
	for s := 0; s < 10; s++ {
		t2.Square(t2)
	}
	t0.Mul(t0, t2)
	t0.Mul(x, t0)
	t3.Square(t0)
	t2.Square(t3)
	for s := 1; s < 2; s++ {
		t2.Square(t2)
	}
	t4.Square(t2)
	for s := 1; s < 22; s++ {
		t4.Square(t4)
	}
	t2.Mul(t2, t4)
	t4.Square(t2)
	for s := 1; s < 20; s++ {
		t4.Square(t4)
	}
	t3.Mul(t3, t4)
	for s := 0; s < 46; s++ {
		t3.Square(t3)
	}
	t2.Mul(t2, t3)
	t3.Square(t2)
	for s := 1; s < 110; s++ {
		t3.Square(t3)
	}
	t2.Mul(t2, t3)
	t1.Mul(t1, t2)
	for s := 0; s < 23; s++ {
		t1.Square(t1)
	}
	t0.Mul(t0, t1)
	for s := 0; s < 7; s++ {
		t0.Square(t0)
	}
	t0.Mul(z, t0)
	for s := 0; s < 3; s++ {
		t0.Square(t0)
	}
	z.Mul(z, t0)

	return e.Set(z)
}
